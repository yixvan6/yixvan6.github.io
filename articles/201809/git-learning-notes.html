<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon-32x32.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="PHP，Laravel，Linux，Git，hehorange，橙子好好吃，呵呵橙，笔记，随笔">
  <meta name="author" content="hehorange">
  <meta name="keywords" content="PHP，Laravel，Linux，Git，hehorange，橙子好好吃，呵呵橙，笔记，随笔">
  <title>Git 学习笔记 - 橙子好好吃</title>

  <!-- 为观影记录组件添加的 meta 头 -->
  <meta name="referrer" content="never">

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night-eighties.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>橙子好好吃</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/movies/">
              <i class="iconfont icon-youtube-fill"></i>
              观影</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              分类</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/post_default_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2018-09-05 22:31">
                    2018年9月5日 晚上
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    6.9k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    79
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  最后更新于：2020年5月12日 晚上
                
              </p>
            
            <article class="markdown-body">
              <p>简单记录，以便之后复习。学习的是 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰 Git 教程</a>，浅显易懂，循序渐进！<br><a href="https://git-scm.com/" target="_blank" rel="noopener"><strong>Git 官网</strong></a> 有中文文档，有更详细的说明。常用的命令运用熟练已足够，若需要更复杂更高级的操作，就要去查文档了。</p>
<h3 id="什么是-Git？"><a href="#什么是-Git？" class="headerlink" title="什么是 Git？"></a>什么是 Git？</h3><p>Git 是目前世界上最先进的 <strong>分布式版本控制系统</strong>。</p>
<h4 id="Git-的诞生："><a href="#Git-的诞生：" class="headerlink" title="Git 的诞生："></a>Git 的诞生：</h4><p><strong>Linus</strong> 在 1991 年创建了开源的 Linux，在全世界的热心志愿者参与下，Linux 不断发展壮大，已经成为最大的服务器系统软件。</p>
<p>Linux 靠世界各地的大牛贡献代码，但代码的管理始终是个问题。<br>在 2002 年之前，志愿者们通过 <code>diff</code> 的方式将代码发给 Linus，然后由他本人手工合并代码。</p>
<p><strong>Linus 为什么不用当时已有版本控制系统呢？</strong></p>
<ol>
<li>CVS 和 SVN，这些集中式版本控制系统速度慢，且必须联网；</li>
<li>一些商业的版本控制系统虽然好用，但要付费，和 Linux 的开源精神不符。</li>
</ol>
<p>到了 02 年，Linux 系统已发展十年，代码库之大已经很难通过手工方式管理，于是不得不选择一个版本控制系统，Linus 选择了商业的 BitKeeper，而 BitKeeper 的公司 BitMover 出于人道主义精神，授权 Linux 社区免费使用。</p>
<p>好景不长，2005 年时，Linux 社区的 Andrew 试图破解 BitKeeper 的协议，被 BitMover 公司发现，于是收回了 Linux 社区的免费使用权。</p>
<p>Linus 没有重新选择另一个版本控制系统，而是花了 <strong>2周时间</strong> 自己用 C 写了一个分布式版本控制系统，便是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了。</p>
<p>Git 迅速成为最流行的分布式版本控制系统，到了2008年，GitHub 网站上线，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等。</p>
<h4 id="集中式-vs-分布式"><a href="#集中式-vs-分布式" class="headerlink" title="集中式 vs 分布式"></a>集中式 vs 分布式</h4><ul>
<li><p>集中式：版本库存放在中央服务器，每次干活前，先从中央服务器取得最新的版本，干完活后再推送给中央服务器。<br>最大的问题是必须联网才能工作，如果网速慢的话，非常费时间。一旦中央服务器崩溃，所有人都无法工作。</p>
</li>
<li><p>分布式：每个人的电脑上都是完整的版本库，所以就不用联网了。多人协作时，只需将自己的修改互相推送。而这里的“中央服务器”只是方便大家交换修改，没有它照样可以工作，只是有了它交换更方便而已。<br>另外，Git 的优势还有强大的 <strong>分支管理</strong>。</p>
</li>
</ul>
<blockquote>
<p>常见的版本控制系统有：<br>集中式：CVS(最早，不稳定)、SVN(最流行)、ClearCase(IBM的，商用，大，慢)、VSS(微软自己的)等<br>分布式：Git(最快，最流行)、BitKeeper、Mercurial、Bazaar 等</p>
</blockquote>
<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>Git 最开始只能在 Linux 和 Unix 系统上运行，现在也可以在 Mac 和 Windows 上运行。</p>
<p>Windows 上安装：</p>
<blockquote>
<p>下载 Git 安装，包含了 Git Bash 和 Git GUI。<br>下载 msysgit 安装，msysgit 已将所需模拟环境和 Git 打包，默认安装即可。<br>下载 GitHub 安装，包含了可视化工具 GitHub 和命令行窗口 Git Shell 。</p>
</blockquote>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>版本库（Repository），库里的每个文件都能被 Git 跟踪</p>
<p><strong>&gt; 创建库</strong></p>
<ol>
<li><p>先创建一个空目录（如 …\GitHub\study）</p>
<div class="hljs"><pre><code class="hljs bash">mkdir study
<span class="hljs-built_in">cd</span> study
<span class="hljs-built_in">pwd</span>      // 显示当前目录</code></pre></div>
</li>
<li><p>将这个目录变成 Git 可管理的仓库</p>
<div class="hljs"><pre><code class="hljs plain">git init</code></pre></div>
<p>于是建成了一个空的仓库，此时 study 目录下多了一个 <strong>.git</strong> 的隐藏目录</p>
</li>
</ol>
<p><strong>&gt; 添加文件入库</strong></p>
<div class="hljs"><pre><code class="hljs bash">git add readme.txt
git commit -m <span class="hljs-string">"add a readme.txt"</span></code></pre></div>
<p>可以多次 add，只需一次 commit</p>
<h3 id="时空穿梭"><a href="#时空穿梭" class="headerlink" title="时空穿梭"></a>时空穿梭</h3><p><strong>&gt; 基本操作</strong></p>
<div class="hljs"><pre><code class="hljs bash">git status      // 查看工作区状态
git diff readme.txt      // 查看不同

git add readme.txt
git status

git commit -m <span class="hljs-string">"add word distributed"</span>
git status</code></pre></div>

<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>每 commit 一次，就在 git 里保存了一个「快照」</p>
<div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>      // 查看版本历史记录，从最近的版本到最远排列
git <span class="hljs-built_in">log</span> --pretty==oneline      // 添加参数简化信息
/*
d1e563cda89f530ac466e3c0ed216a9f814ad700 append GPL
c5e16db582973fcaf9e1b7ab534c83b22d206221 add word distributed
18010d7984d1b9e693ad98a15372da6177f54366 add a readme.txt
*/</code></pre></div>
<p>如上，每个版本对应一个 <strong>commit id</strong>(经过特殊处理，防止冲突)</p>
<p>可用 <strong>reset</strong> 来回退到指定版本：</p>
<div class="hljs"><pre><code class="hljs bash">git reset --hard HEAD^</code></pre></div>
<p>HEAD 表示当前版本，HEAD^ 表示上一个，HEAD^^ 表示上上一个，HEAD~10 表示往上10个版本<br>回退到上一个版本后再查看：</p>
<div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>
/* 
c5e16db582973fcaf9e1b7ab534c83b22d206221 add word distributed
18010d7984d1b9e693ad98a15372da6177f54366 add a readme.txt 
*/</code></pre></div>
<p>发现”append GPL”版本没有了，怎么办？<br>如果还知道那个版本的 id，则：</p>
<div class="hljs"><pre><code class="hljs plain">git reset --hard d1e563cd(版本号没必要写全)&#96;</code></pre></div>
<p>如果找不到版本的id了，则</p>
<div class="hljs"><pre><code class="hljs bash">git reflog
/*
c5e16db HEAD@&#123;0&#125;: reset: moving to HEAD^
d1e563c HEAD@&#123;1&#125;: commit: append GPL
c5e16db HEAD@&#123;2&#125;: commit: add word distributed
18010d7 HEAD@&#123;3&#125;: commit (initial): add a readme.txt
*/</code></pre></div>
<p>又能找到版本的 id 了</p>
<h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>工作区(working directory)：在你的电脑里能看到的目录<br>版本库(repository)：工作区中隐藏的目录 .git，就是版本库</p>
<p>.git 里存了很多东西，最重要的就是 stage(或叫 index)的暂存区，还有自动创建的 master 分支，以及指向 master 的指针 HEAD</p>
<p>暂存区如何工作？（详看教程文档p25-27）<br>将工作区的修改，添加到 stage，再将 stage 的所有修改提交到分支。</p>
<h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>Git 管理的是修改，而不是文件。删除内容、增添内容、修改内容、新增文件、删除文件等等，都算修改。</p>
<blockquote>
<p><strong>！</strong> 所有工作区的修改都必须先 add 到 stage，才能提交成功。</p>
</blockquote>
<p>如果没有 add，那只会提交 stage 中的修改，而不是工作区的修改。<br>比如：<br>第一次修改 &gt; add &gt; 第二次修改 &gt; commit<br>因为只有第一次修改添加到 stage，所以只提交了第一次修改<br>第一次修改 &gt;add &gt; 第二次修改 &gt; add &gt; commit<br>这样两次修改都提交了</p>
<p>查看工作区和最新版本的区别：</p>
<div class="hljs"><pre><code class="hljs plain">git diff HEAD -- readme.txt</code></pre></div>

<p><strong>！ git diff 说明：</strong></p>
<div class="hljs"><pre><code class="hljs plain">git diff      比较工作区和暂存区
git diff HEAD      比较工作区和版本库
git diff --cached      比较暂存区和版本库</code></pre></div>

<p><strong>&gt; 撤销修改</strong><br>工作区的修改，怎么撤销？</p>
<div class="hljs"><pre><code class="hljs plain">git checkout -- readme.txt    &#x2F;&#x2F; 特定文件
git reset --hard HEAD      &#x2F;&#x2F; 所有修改
git clean -f      &#x2F;&#x2F; 未追踪的文件（即新增的文件），常与上一个命令配合使用</code></pre></div>

<p>已添加到暂存区的修改，怎么撤销？</p>
<div class="hljs"><pre><code class="hljs plain">git reset HEAD readme.txt</code></pre></div>

<p>这样便把暂存区的修改撤销(unstage)，重新放到工作区</p>
<p>如果已经提交，怎么办？<br>版本回退，回退到上一个版本，前提是没有推送到远程库。</p>
<p><strong>&gt; 删除文件</strong><br>先添加一个 test.txt 并提交<br>删除：<code>rm test.txt</code></p>
<p>若是误删想恢复，同撤销修改相同：</p>
<div class="hljs"><pre><code class="hljs bash">git checkout -- test.txt</code></pre></div>

<p>确实要删：</p>
<div class="hljs"><pre><code class="hljs bash">git rm test.txt
git commit -m <span class="hljs-string">"remove test.txt"</span></code></pre></div>

<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>Git 是分布式版本控制系统，同一个 Git 仓库，可以分布到不同的机器上。怎么分布呢？</p>
<p>最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实中是不会有人在一台电脑上搞几个远程库玩，完全没有意义。</p>
<p>实际情况往往是，找一台电脑充当服务器的角色，全天开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>为了学 Git 先搭建个服务器绝对是小题大做，好在有很多代码托管网站，比如 GitHub，免费提供托管服务，免费获得 Git 远程仓库。</p>
<p>因为本地 Git 仓库和 GitHub 仓库之间是通过 SSH 加密，所以，要先设置：</p>
<ul>
<li>创建 SSH Key：<div class="hljs"><pre><code class="hljs plain">ssh-keygen -t rsa -C &quot;yixvan6@163.com&quot;</code></pre></div>
一路回车，使用默认值，也无需设置密码。</li>
</ul>
<p>如果成功，会在用户主目录里找到 <strong>.ssh</strong> 目录，里面有 <code>github_rsa</code> 和 <code>github_rsa.pub</code> 两个文件，一个是私钥，不能泄露，一个是公钥，可以公开。<br>如果已经有这两个文件，那直接第二步。</p>
<ul>
<li><p>添加 SSH Key 到 GitHub：<br>登录 GitHub，<code>Settings &gt; SSH and GPG keys</code><br>点”New SSH key”，Title 任意填写，Key 文本框里粘贴 github_rsa.pub 文件的内容，然后确认。</p>
</li>
<li><p>测试 ssh key 是否成功：</p>
<div class="hljs"><pre><code class="hljs plain">ssh -T git@github.com</code></pre></div>
<p>如果出现 You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上 GitHub，否则会显示 access denied。</p>
</li>
</ul>
<p>可添加 <strong>多个</strong> Key，使你在不同的电脑上都能推送到自己的 GitHub</p>
<blockquote>
<p>提示：<br>GitHub 免费托管 Git 仓库，但任何人都能看到(只有自己能改)，是公开的。<br>若想不让别人看到，i.付费；ii.自己搭建 Git 服务器。</p>
</blockquote>
<h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>登陆 GitHub &gt; <code>New repository</code>，创建新库。<br>目前是空的，可以把已有的本地库与之关联，然后，把本地库的内容推送到 GitHub 库</p>
<div class="hljs"><pre><code class="hljs bash">git remote add origin git@github.com:yixvan6/study.git    // origin是代表远程库的名称
git push -u origin master      // 推送所有内容，实际是推送当前分支master
// -u 是首次推送时与分支关联</code></pre></div>
<p>以后提交，就通过 <code>git push origin master</code></p>
<h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><p>克隆到本地：</p>
<div class="hljs"><pre><code class="hljs plain">git clone git@github.com:yixvan6&#x2F;gitskills.git</code></pre></div>
<p>Git 支持多种协议，包括 https，但 ssh 最快。</p>
<p><strong>&gt; 从远程库同步修改</strong><br>有时候修改是在远程库完成的，需要把远程的修改拉到本地库，使之相同<br>介绍两种方式：</p>
<ul>
<li><p>fetch 或 merge</p>
<div class="hljs"><pre><code class="hljs bash">git remote -v      // 查看有哪些远程仓库,本例为一个
/*
origin  git@github.com:yixvan6/yixvan6.github.io.git (fetch)
origin  git@github.com:yixvan6/yixvan6.github.io.git (push)
*/

git fetch origin master      // 从远程获取最新版本到本地

git merge origin/master      // 将远程下载的代码合并到本地库</code></pre></div>
</li>
<li><p>pull</p>
<div class="hljs"><pre><code class="hljs bash">git pull origin master      // 下载并合并</code></pre></div>

</li>
</ul>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支之间各自独立，互不干扰，既安全，又不影响别人工作。自己的开发完毕之后，可以一次性合并到原来的分支上。</p>
<p>其他的版本控制系统如 SVN 等也有分支管理，但分支的创建和切换非常慢，几乎成了摆设。<br>但 Git 的分支无论是创建、切换还是删除，都能迅速完成，无论你的版本库是1个文件还是上万个文件。</p>
<h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><p>Git 的每次提交，都把它们串成一条时间线，这条时间线就是一个分支。目前我们只有一条时间线，默认为 <code>master</code> 分支，也称为主分支。<br><code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，而 <code>master</code> 才指向提交，所以，<code>HEAD</code> 指向当前分支。</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202156.png" srcset="/img/loading.gif" alt="git-branch1"></p>
<p>每次提交，<code>master</code> 分支都向前移动一步，随着不断提交，分支的线也越来越长。<br>当创建新分支，例如 <code>dev</code>，Git 新建了一个指针叫 <code>dev</code>，指向 <code>master</code> 相同的提交，再把 <code>HEAD</code> 指向 <code>dev</code>，就表示当前在 <code>dev</code> 分支上：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202234.png" srcset="/img/loading.gif" alt="git-branch2"></p>
<p>从现在起，修改和提交就是针对 <code>dev</code> 分支了，<code>dev</code> 指针向前移动，而 <code>master</code> 指针不变：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202324.png" srcset="/img/loading.gif" alt="git-branch3"></p>
<p>假如我们在新分支上的工作完成了，可以将其合并到主分支上。最简单的方法，就是把 <code>master</code> 指向 <code>dev</code> 的当前提交，完成合并：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202552.png" srcset="/img/loading.gif" alt="git-branch4"></p>
<p>合并完成后，如果要删除 <code>dev</code> 分支，只要删除这个分支对应的指针就可以了，删除后，只剩下了主分支：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202615.png" srcset="/img/loading.gif" alt="git-branch5"></p>
<p><strong>&gt; 具体命令</strong><br>理解了原理，我们来了解具体的命令来实现。<br>创建分支：</p>
<div class="hljs"><pre><code class="hljs plain">git checkout -b dev      &#x2F;&#x2F; 加上 -b 参数表示创建并切换，相当于下面两条命令

git branch dev
git checkout dev</code></pre></div>
<p>然后，查看当前分支：</p>
<div class="hljs"><pre><code class="hljs plain">git branch      &#x2F;&#x2F; 列出所有分支，并用 * 号标出当前分支</code></pre></div>
<p>这时做一次新的提交，再切换到主分支查看，会发现没有变化，因为那个提交是在 <code>dev</code> 分支上，不会影响到 <code>master</code> 分支。</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202634.png" srcset="/img/loading.gif" alt="git-branch6"></p>
<p>现在，将 <code>dev</code> 分支上的工作成果合并到 <code>master</code> 分支上：</p>
<div class="hljs"><pre><code class="hljs plain">git merge dev</code></pre></div>
<p><code>git merge</code> 用于将指定分支合并到当前分支，这时再查看修改，会发现与 <code>dev</code> 分支的最新提交是一样的。<br>合并完成，可以放心删除了：</p>
<div class="hljs"><pre><code class="hljs plain">git branch -d dev

&#x2F;&#x2F; 如果没有合并想直接删除
git branch -D dev</code></pre></div>

<p>！因为 Git 的分支操作只是改变指针，所以速度非常快，所以「鼓励」使用分支完成某个任务，合并后再删除分支，这跟直接在主分支上工作效果是一样的，但过程更安全。</p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>先创建一个新分支来演示：</p>
<div class="hljs"><pre><code class="hljs plain">git checkout -b feature1</code></pre></div>
<p>修改 <code>readme.txt</code> 文件，然后提交。<br>切换到主分支，修改 <code>readme.txt</code>，提交。<br>合并 <code>feature1</code> 分支，因为两次修改并不相同，所以出现冲突：</p>
<div class="hljs"><pre><code class="hljs plain">git checkout master
...
git merge feature1
git status    &#x2F;&#x2F; 可查看冲突的文件</code></pre></div>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202731.png" srcset="/img/loading.gif" alt="git-branch7"></p>
<p><strong>解决：</strong><br>先查看文件，发现 Git 帮我们标记出来了冲突，用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记不同分支的内容：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202757.png" srcset="/img/loading.gif" alt="git-diff1"></p>
<p>手动修改后保存，提交。这样就解决了冲突，分支关系如下：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202814.png" srcset="/img/loading.gif" alt="git-branch8"></p>
<p>最后即可删除 <code>feature1</code> 分支。</p>
<h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常，合并分支时，如果可能，Git 会用 <code>Fast forward</code> 模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用 <code>Fast forward</code> 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p>
<p>我们创建一个新分支 <code>dev</code>，并做一次提交。然后切换回主分支用普通模式(即非’ff’模式)来合并：</p>
<div class="hljs"><pre><code class="hljs plain">git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></pre></div>
<p>因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。<br>不使用 <code>Fast forward</code> 模式，合并后像这样：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504202829.png" srcset="/img/loading.gif" alt="git-branch9"></p>
<p><strong>&gt; 分支策略</strong><br>实际开发中，应该按照这个原则进行分支管理：<br>首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>干活都在 dev 分支上，也就是说，dev 分支是不稳定的，到某个时候，比如1.0版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504203012.png" srcset="/img/loading.gif" alt="git-branch10"></p>
<h4 id="Bug-分支"><a href="#Bug-分支" class="headerlink" title="Bug 分支"></a>Bug 分支</h4><p>软件开发中，bug 就像家常便饭。在Git中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>通常会碰到一种情况：当收到任务要立即修复某 bug，但当前正在进行的工作还没有完成，没法提交。<br>Git 提供了一个 <strong>stash</strong> 功能，可以把当前工作现场暂存起来，等修复完 bug 再回来恢复现场继续工作。</p>
<p>具体流程：</p>
<div class="hljs"><pre><code class="hljs plain">git stash      &#x2F;&#x2F; 暂存当前工作
git checkout master      &#x2F;&#x2F; 切换回 master 分支（假定需要在 master 分支上修复该 bug）
git checkout -b bug-x      &#x2F;&#x2F; 从 master 分支创建临时分支

&#x2F;&#x2F; 修复完成，提交后，切换回 master 分支，合并，最后删除 bug-x 分支

git checkout dev      &#x2F;&#x2F; 切换到之前工作的分支
git stash list      &#x2F;&#x2F; 查看 stash 列表
git stash pop      &#x2F;&#x2F; 恢复工作现场并删除 stash，等同于下面两个命令
git stash apply      &#x2F;&#x2F; 恢复
git stash drop      &#x2F;&#x2F; 删除</code></pre></div>
<p>可以多次 <code>stash</code>，恢复时，先查看，然后用对应标号恢复</p>
<div class="hljs"><pre><code class="hljs plain">git stash apply stash@&#123;0&#125;</code></pre></div>

<blockquote>
<p><strong>｛Note｝</strong>在 dev 分支的修改，无论是否 add 到 stage，切换回 master 分支时都可以看到修改；<br>无论是否 add，都可以进行 stash 暂存。</p>
</blockquote>
<h4 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h4><p>同 bug 临时分支一样，在开发新功能时，以防一些实验性质的代码搞乱了主分支，最好新建一个 feature 分支，等新功能开发完成后，合并，这个 feature 分支就可以删除了。</p>
<h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><p>当从远程库克隆时，Git 会把本地 master 分支和远程的 master 分支对应起来，远程的仓库默认名称为 <code>origin</code>。<br>查看远程库的信息：</p>
<div class="hljs"><pre><code class="hljs plain">git remote
git remote -v      &#x2F;&#x2F; 会显示抓取和推送的地址，如果没有推送权限，就看不到 push 的地址</code></pre></div>

<p><strong>&gt; 推送分支</strong><br>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上：</p>
<div class="hljs"><pre><code class="hljs plain">git push origin master

&#x2F;&#x2F; 推送其他分支，比如 dev
git push origin dev</code></pre></div>

<p>但是，并不一定要把本地所有分支推送到远程，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li>master 分支是主分支，因此要时刻与远程同步；</li>
<li>dev 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个 bug；</li>
<li>feature 分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。<br>总之，在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</li>
</ul>
<p><strong>&gt; 抓取分支</strong><br>多人协作时，大家都会往 master 和 dev 分支上推送各自的修改。</p>
<p>模拟一下场景：假设现在有 C 君，要在另一台电脑上克隆项目。</p>
<blockquote>
<p><strong>{Note}</strong> 从远程库克隆时，默认情况下，只能看到本地的 master 分支。</p>
</blockquote>
<p>C 君要在 <code>dev</code> 分支上开发，先要创建远程 <code>dev</code> 分支到本地：</p>
<div class="hljs"><pre><code class="hljs plain">git checkout -b dev origin&#x2F;dev</code></pre></div>
<p>现在，他可以在 <code>dev</code> 分支上工作了，并时不时地把分支 <code>push</code> 到远程。</p>
<p>C 君已向远程推送了提交，恰巧，你也做了修改，并试图推送：</p>
<div class="hljs"><pre><code class="hljs plain">git push origin dev</code></pre></div>
<p>但却推送失败，因为 C 君的最新提交和你要推送的提交有冲突。要解决冲突，先要把最新的提交抓取下来，然后在本地合并，解决冲突，再推送：</p>
<div class="hljs"><pre><code class="hljs plain">git pull</code></pre></div>
<p>但抓取也失败了，原因是没有指定本地 <code>dev</code> 分支和远程 <code>origin/dev</code> 的链接，根据 Git 的提示，设置链接：</p>
<div class="hljs"><pre><code class="hljs plain">git branch --set-upstream-to&#x3D;origin&#x2F;dev dev</code></pre></div>
<p>这时再 <code>git pull</code>，抓取成功，但合并有冲突，需要手动修改冲突。<br>解决冲突后提交，最后 <code>push</code>。</p>
<p><strong>总结</strong> 一下过程：</p>
<ol>
<li>试图 <code>git push origin dev</code> 推送修改；</li>
<li>若推送失败，则因为远程分支比你本地的更新，先用 <code>git pull</code> 抓取并合并；</li>
<li>若抓取失败，并提示 <code>no tracking information</code>，则是没有建立本地分支与远程的链接，先设置链接再 <code>pull</code>；</li>
<li>若合并有冲突，则先解决冲突，解决后再推送。</li>
</ol>
<h4 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h4><p>多人在同一分支上协作时，很容易出现冲突。即使没有冲突，后推送的童鞋不得不先 <code>pull</code>，在本地合并，才能推送成功。<br>每次合并再推送后，分支线就变得很凌乱，如下：</p>
<p><img src="https://gitee.com/yixvan6/img/raw/master/img/20200504203210.png" srcset="/img/loading.gif" alt="git-log1"></p>
<p>Git 有一种 <code>rebase</code> 操作，可以将提交历史变为一条直线！所以有人亲切地将其称为「变基」</p>
<p>举例说明：<br>查看提交历史，远程的最新提交是 <code>init hello</code>，而自上次推送后我们又在本地新增了两次提交，<code>add comment</code> 和 <code>add author</code>，即本地比远程提前两个提交。</p>
<div class="hljs"><pre><code class="hljs plain">$ git log --graph --pretty&#x3D;oneline --abbrev-commit
* 582d922 (HEAD -&gt; master) add author
* 8875536 add comment
* d1be385 (origin&#x2F;master) init hello
*   e5e69f1 Merge branch &#39;dev&#39;
...</code></pre></div>
<p>现在我们要去推送这两次提交：<code>git push origin master</code><br>但是失败了，说明有人先于我们推送，应该先抓取合并一下：<code>git pull</code><br>没有冲突，抓取合并成功。<br>再查看一下提交历史，加上刚才合并的提交，现在本地比远程提前三个提交：</p>
<div class="hljs"><pre><code class="hljs plain">$ git log --graph --pretty&#x3D;oneline --abbrev-commit
*   e0ea545 (HEAD -&gt; master) Merge branch &#39;master&#39; of github.com:michaelliao&#x2F;learngit
|\  
| * f005ed4 (origin&#x2F;master) set exit&#x3D;1
* | 582d922 add author
* | 8875536 add comment
|&#x2F;  
* d1be385 init hello
...</code></pre></div>
<p>唉，怎么多了个分叉？如果现在提交，强迫症表示不能接受，那怎么办？<br>用 <code>rebase</code> 来变基操作：</p>
<div class="hljs"><pre><code class="hljs plain">git rebase</code></pre></div>
<p>变基后，再来查看提交历史：</p>
<div class="hljs"><pre><code class="hljs plain">$ git log --graph --pretty&#x3D;oneline --abbrev-commit
* 7e61ed4 (HEAD -&gt; master) add author
* 3611cfe add comment
* f005ed4 (origin&#x2F;master) set exit&#x3D;1
* d1be385 init hello
...</code></pre></div>
<p>分叉没了！这下清爽多了，可以开心推送了：<code>git push origin master</code><br>再来看看效果，远程分支也是一条直线：</p>
<div class="hljs"><pre><code class="hljs plain">$ git log --graph --pretty&#x3D;oneline --abbrev-commit
* 7e61ed4 (HEAD -&gt; master, origin&#x2F;master) add author
* 3611cfe add comment
* f005ed4 set exit&#x3D;1
* d1be385 init hello
...</code></pre></div>

<p><strong>总结：</strong><br>有了 <code>rebase</code> 可以把本地「未推送」的分叉提交历史整理成直线，这样看起来会更直观。但变基之后相关推送的 commit id 会发生改变。<br>另外，在 <code>rebase</code> 过程中还可能发生冲突，就需要其他操作了，这篇文章可作为参考：<a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">rebase</a></p>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，通常会在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 <code>commit</code> 的指针（跟分支很像，但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>有了 <code>commit</code>，为什么还要引入 <code>tag</code>？<br>因为 commit id 是一串字符串，不好查找。有了标签，可以迅速找到对应的 <code>commit</code>。</p>
<p>所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><div class="hljs"><pre><code class="hljs plain">git tag &lt;name&gt;      &#x2F;&#x2F; 创建标签

git tag      &#x2F;&#x2F; 查看所有标签</code></pre></div>
<p>默认标签对应到最新提交，如果要在历史提交上打标签，需要先找到对应提交的 commit id：</p>
<div class="hljs"><pre><code class="hljs plain">git tag &lt;name&gt; &lt;commit id&gt;</code></pre></div>

<blockquote>
<p><strong>{Note}</strong> 查看标签时，标签不是按时间顺序列出，而是按字母排序的</p>
</blockquote>
<div class="hljs"><pre><code class="hljs plain">git show &lt;tagname&gt;      &#x2F;&#x2F; 查看标签信息</code></pre></div>

<p>还可以创建有说明的标签：</p>
<div class="hljs"><pre><code class="hljs plain">git tag -a v0.3 -m &quot;version 0.3 released&quot; 1094adb</code></pre></div>

<blockquote>
<p><strong>注意</strong><br>标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。</p>
</blockquote>
<h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><div class="hljs"><pre><code class="hljs plain">git tag -d v0.3      &#x2F;&#x2F; 删除标签</code></pre></div>
<p>标签只存储在本地，不会自动推送到远程。若要推送标签：</p>
<div class="hljs"><pre><code class="hljs plain">git push origin v1.0      &#x2F;&#x2F; 推送单个标签
git push origin --tags      &#x2F;&#x2F; 推送所有未推送过的本地标签</code></pre></div>

<p>若标签已推送到远程，要删除远程标签：</p>
<div class="hljs"><pre><code class="hljs plain">git tag -d v0.9      &#x2F;&#x2F; 需要先删除本地标签
git push origin :refs&#x2F;tags&#x2F;v0.9      &#x2F;&#x2F; 然后再删除远程标签，命令也是 push</code></pre></div>


<h3 id="使用-GitHub"><a href="#使用-GitHub" class="headerlink" title="使用 GitHub"></a>使用 GitHub</h3><p>GitHub 不仅是个远程仓库，还是一个开源协作社区。</p>
<p>利用 Git 强大的克隆和分支功能，人们可以自由参与各种开源项目。</p>
<p><strong>如何参与？</strong><br>访问相关项目的 GitHub 主页，点 <strong>Fork</strong> 就在自己的账号下克隆一个相同仓库，然后再从自己的仓库克隆到本地<br>（！必须从自己的仓库克隆，不然没有权限推送）</p>
<p>推送修改到自己的仓库，如果想让项目官方接受你的修改，就可以发起一个 <strong>pull request</strong>，是否接受就是对方的权限了。</p>
<h3 id="自定义-Git"><a href="#自定义-Git" class="headerlink" title="自定义 Git"></a>自定义 Git</h3><p>在安装 Git 一节中，我们已经配置了 user.name 和 user.email，实际上，Git 还有很多可配置项。</p>
<p>比如，让 Git 显示颜色，会让命令输出看起来更醒目：</p>
<div class="hljs"><pre><code class="hljs plain">$ git config --global color.ui true</code></pre></div>
<p>这样，Git 会适当地显示不同的颜色，比如 git status 命令，文件名就会标上颜色。</p>
<h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><p>有时候，某些文件并不需要放入版本库进行管理，但工作目录又少不了它们，比如配置文件，这时就要创建一个 <code>.gitignore</code> 文件来让 Git 忽略它们。</p>
<p>在项目根目录或者特定目录中新建 <code>.gitignore</code> 文件，将要忽略的文件名写入即可。可以是某个文件，某个文件夹。<br><a href="https://github.com/github/gitignore" target="_blank" rel="noopener"><code>github/gitignore</code></a> 提供了很多示例，可以参考。<br>当然，别忘了提交 <code>gitignore</code> 文件。</p>
<p><strong>&gt; 忽略文件的原则：</strong></p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等。也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略带有敏感信息的文件，比如存放口令的配置文件。</li>
</ol>
<p>另外，如果某个文件已被忽略，但确实想添加，可以用 <code>-f</code> 强制添加：</p>
<div class="hljs"><pre><code class="hljs plain">git add -f .env</code></pre></div>

<h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>配置别名可以有效地「偷懒」<br>比如，之前学到的命令 <code>git reset HEAD file</code>，将暂存区的内容撤销，重新放回工作区，可以配置为 <code>unstage</code></p>
<div class="hljs"><pre><code class="hljs plain">git config --global alias.unstage &#39;reset HEAD&#39;</code></pre></div>
<p>比如，配置一个命令来查看最近一次提交：</p>
<div class="hljs"><pre><code class="hljs plain">git config --global alias.last &#39;log -1&#39;</code></pre></div>
<p>比如，将复杂的命令简化，用 <code>git lg</code> 查看漂亮可视化的提交历史：</p>
<div class="hljs"><pre><code class="hljs plain">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></pre></div>

<p><strong>配置文件</strong><br>在配置时若加上 <code>--global</code> 参数，表示全局配置所有仓库，但只对当前用户起作用；<br>如果不加，只对当前仓库起作用。</p>
<p>如果加上全局参数，配置文件在用户主目录下的 <code>.gitconfig</code> 文件；<br>如果不加，会在对应仓库的 <code>.git/config</code> 文件中。</p>
<p>配置文件可以自定义修改，别名配置也可以在其中修改，如果改错了，可以删除配置文件重新通过命令配置。</p>
<h4 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h4><p>搭建 Git 服务器很简单，主要在于权限的管理。<br>现在还用不到，就不记录了。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Git/">Git</a>
                    
                      <a class="hover-with-bg" href="/tags/GitHub/">GitHub</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/articles/201809/hexo-blog-building-records.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hexo 博客搭建记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/articles/201809/sublime-text-from-installation-to-configuration.html">
                        <span class="hidden-mobile">Sublime Text从安装到配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script defer src="https://cdn.staticfile.org/valine/1.4.14/Valine.min.js" ></script>

  <script type="text/javascript">
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();

      new Valine({
        el: "#vcomments",
        app_id: "QE9zukzKtTExVYPgQcRNinBu-MdYXbMMI",
        app_key: "yXWKt3QeCzAdqcP0MEU0WU5u",
        placeholder: "说点什么吧~~",
        path: window.location.pathname,
        avatar: "retro",
        meta: ["nick","mail","link"],
        pageSize: "10",
        lang: "zh-CN",
        highlight: false,
        recordIP: false,
        serverURLs: "",
      });
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'false' === 'true',
      loop: 'all',
      order: 'random',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"Black","artist":"Danger Mouse$Daniele Luppi","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/Black%20-%20Danger%20Mouse%26Daniele%20Luppi.mp3","cover":"https://y.gtimg.cn/music/photo_new/T002R300x300M000001hw1hV2MsSjb.jpg"},{"name":"U-Turn","artist":"Nicola Piovani","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/U-Turn%20%28Lili%29%20-%20Nicola%20Piovani.mp3","cover":"https://p3.music.126.net/FP1JjtVkmkkipdKTI7rhLw==/1684451813758720.jpg"},{"name":"拒绝情话","artist":"庆庆","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E6%8B%92%E7%BB%9D%E6%83%85%E8%AF%9D%20-%20%E5%BA%86%E5%BA%86.mp3","cover":"https://p3.music.126.net/rG7zE6K3A373UH8XHI_NqQ==/109951163400201893.jpg"},{"name":"アイロニ","artist":"majiko","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E3%82%A2%E3%82%A4%E3%83%AD%E3%83%8B%20-%20majiko.mp3","cover":"https://y.gtimg.cn/music/photo_new/T002R300x300M000004GC5gr1Djev0.jpg"},{"name":"萨琳娜","artist":"张尧","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E8%90%A8%E7%90%B3%E5%A8%9C%20-%20%E5%BC%A0%E5%B0%A7.mp3","cover":"https://y.gtimg.cn/music/photo_new/T002R300x300M000000kT79D3XFaYJ.jpg"},{"name":"絆","artist":"miu-clips","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E7%B5%86%20-%20miu-clips.mp3","cover":"5TLKyo1Ta7Yg==/109951163338271797.jpg"},{"name":"圆","artist":"AGA","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E5%9C%86%20-%20AGA.mp3","cover":"https://y.gtimg.cn/music/photo_new/T002R300x300M000000V9yae4XbyxL.jpg"},{"name":"充电器","artist":"コアラモード","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E5%85%85%E7%94%B5%E5%99%A8%20-%20%E3%82%B3%E3%82%A2%E3%83%A9%E3%83%A2%E3%83%BC%E3%83%89.mp3","cover":"https://p3.music.126.net/hLC4zRBvnQslwmx19EJCvQ==/18565253836759289.jpg"},{"name":"记昨日书","artist":"伏仪","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E8%AE%B0%E6%98%A8%E6%97%A5%E4%B9%A6%20-%20%E4%BC%8F%E4%BB%AA.mp3","cover":"https://y.gtimg.cn/music/photo_new/T002R300x300M000004dZ9EI1JDzsW.jpg"},{"name":"The Flood","artist":"Joshua Hyslop","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/The%20Flood%20-%20Joshua%20Hyslop.mp3","cover":"https://y.gtimg.cn/music/photo_new/T002R300x300M0000037uJuv3VB1Do.jpg"},{"name":"雨下一整晚","artist":"周杰伦","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E9%9B%A8%E4%B8%8B%E4%B8%80%E6%95%B4%E6%99%9A%20-%20Jay.mp3","cover":"https://y.gtimg.cn/music/photo_new/T002R300x300M000000bviBl4FjTpO.jpg"},{"name":"Think Again","artist":"Kate Havnevik","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/Think%20Again%20-%20Kate%20Havnevik.mp3","cover":"https://p3.music.126.net/XfcPoljRr2ONWK3A40fa2g==/827932255760293.jpg"},{"name":"It Takes A Lot To Konw A Man","artist":"Damien Rice","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/It%20Takes%20A%20Lot%20To%20Konw%20A%20Man%20-%20Damien%20Rice.mp3","cover":"https://y.gtimg.cn/music/photo_new/T002R300x300M0000018GfAl2V7XR8.jpg"},{"name":"日が落ちるまで","artist":"ハンバート ハンバート","url":"https://blog-musics.oss-cn-shanghai.aliyuncs.com/%E6%97%A5%E3%81%8C%E8%90%BD%E3%81%A1%E3%82%8B%E3%81%BE%E3%81%A7%20-%20%E3%83%8F%E3%83%B3%E3%83%90%E3%83%BC%E3%83%88%20%E3%83%8F%E3%83%B3%E3%83%90%E3%83%BC%E3%83%88.mp3","cover":"https://p3.music.126.net/RqP5ECFl5Qy-x-obsuudKQ==/938982930120740.jpg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <!-- 一言 -->
    <p id="hitokoto" style="font-weight: bold;font-size: 17px;color: #4ecdc4;">好好学习，天天向上</p>
    <p id="from" style="font-style: italic;color: #1a535c"></p>

    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love" style="color: #ff6b6b"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->


  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?3a1762ce87be0b3e32c5317edbad11c1";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Git 学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>
















<!-- 加入一言 -->
<script>
  fetch('https://v1.hitokoto.cn?c=d&c=i&c=k')
    .then(response => response.json())
    .then(data => {
      const hitokoto = document.getElementById('hitokoto')
      hitokoto.innerText = '“' + data.hitokoto + '”'
      const from = document.getElementById('from')
      from.innerText = '——— 《' + data.from + '》'
      })
      .catch(console.error)
</script>


</body>
</html>
